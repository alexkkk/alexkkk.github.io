---
title: Go中接受值和接受指针的成员函数比较
date: 2016-12-05 21:03:15
tags:
---

在将golang的interface和指针混用的时候经常出错，写个文章总结下

## 定义

```go
package main

import "fmt"

type Mutatable struct {
    a int
    b int

}

/// 接受值的成员函数
/// non-pointer receiver
func (m Mutatable) StayTheSame() {
    m.a = 5
    m.b = 7

}

/// 接受指针的成员函数
/// pointer receiver
func (m *Mutatable) Mutate() {
    m.a = 5
    m.b = 7
}

func main() {
    m := &Mutatable{0, 0}
    fmt.Println(m) 
    m.StayTheSame()
    fmt.Println(m)
    m.Mutate()
    fmt.Println(m)
}

```
主要区别如下：
1. non-pointer receiver是值传递的，不能修改结构体的成员，一般在结构体比较小的情况下用
2. pointer receiver是指针传递的，可以修改结构体成员，相对来说比较高效，不需要拷贝结构体

## 问题
看下面这个例子
```go
package main

import (
    "fmt"
)

type IFace interface {
    SetSomeField(newValue string)
    GetSomeField() string
}

type Implementation struct {
    someField string
}

func (i Implementation) GetSomeField() string {
    return i.someField
}

func (i Implementation) SetSomeField(newValue string) {
    i.someField = newValue
}

func Create() IFace {
    obj := Implementation{someField: "Hello"}
    return obj 
}

func main() {
    a := Create()
    a.SetSomeField("World")
    fmt.Println(a.GetSomeField())
}
```

这种情况下，`SetSomeField`是不能生效的，因为它接受的不是指针
但是，把它改成指针之后，比如向下面这样：
```go
func (i *Implementation) SetSomeField(newValue string) {
    i.someField = newValue
}
```
这个时候编译会报出如下的错误：
```
prog.go:26: cannot use obj (type Implementation) as type IFace in return argument:
Implementation does not implement IFace (GetSomeField method has pointer receiver)
```

怎么办？


## 方案
```go
package main

import (
    "fmt"
)

type IFace interface {
    SetSomeField(newValue string)
    GetSomeField() string
}

type Implementation struct {
    someField string
}    

func (i *Implementation) GetSomeField() string {
    return i.someField
}

func (i *Implementation) SetSomeField(newValue string) {
    i.someField = newValue
}

func Create() IFace {
    return &Implementation{someField: "Hello"}
}

func main() {
    a := Create()
    a.SetSomeField("World")
    fmt.Println(a.GetSomeField())
}
```
