---
title: redis_1_整体架构
date: 2016-06-12 17:01:07
tags: redis
---

## 主流程

int main {
1. zmalloc设置
2. 设置hash函数的seed
3. 检查是不是sentinel模式

4. 初始化server配置
`initServerConfig()`

5. sentinel模式初始化
```cpp
if (server.sentinel_mode) {
    initSentinelConfig();
    initSentinel();
}
```

6. 根据启动参数修改服务器配置

7. 创建daemon进程
`if (server.daemonize) daemonize();`

8. 初始化服务器功能
`initServer()`

9. 创建PID文件

10. 打印redis图标
`redisAsciiArt()`

11. 不是SENTINEL模式，打印服务器信息
```cpp
    if (!server.sentinel_mode) {
        /* Things only needed when not running in Sentinel mode. */
        redisLog(REDIS_WARNING,"Server started, Redis version " REDIS_VERSION);
    #ifdef __linux__
        linuxOvercommitMemoryWarning();
    #endif
        // 从 RDB 文件或 AOF 文件中载入数据
        loadDataFromDisk();
        if (server.ipfd > 0)
            redisLog(REDIS_NOTICE,
                "The server is now ready to accept connections on port %d", 
                server.port);
        if (server.sofd > 0)
            redisLog(REDIS_NOTICE,
                "The server is now ready to accept connections at %s", 
                server.unixsocket);
    }
```

12. 打印内存限制告警
```cpp
    if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {
        redisLog(REDIS_WARNING,
            "WARNING: You specified a maxmemory value "
            "that is less than 1MB (current value is %llu bytes). "
            "Are you sure this is what you really want?", 
            server.maxmemory);
    }
```

13. 设置时间执行前要运行的函数
`aeSetBeforeSleepProc(server.el,beforeSleep);`

14. 启动服务器循环
`aeMain(server.el);`

15. 关闭服务器，删除事件
`aeDeleteEventLoop(server.el);`

}

## initServer初始化服务器
void initServer() {
1. 信号处理设置
2. LOG处理
3. 全局redisServer设置
4. 初始化共享对象
5. 初始化事件状态
6. 初始化数据库
7. 初始化网络连接
```cpp
    if (server.port != 0) {
        ///创建socket并监听
        server.ipfd = anetTcpServer(server.neterr,server.port,server.bindaddr);
        if (server.ipfd == ANET_ERR) {
            redisLog(REDIS_WARNING, "Opening port %d: %s", server.port, server.neterr);
            exit(1);
        }
    }

    if (server.unixsocket != NULL) {
        unlink(server.unixsocket); /* don't care if this fails */
        server.sofd = anetUnixServer(server.neterr,server.unixsocket,server.unixsocketperm);
        if (server.sofd == ANET_ERR) {
            redisLog(REDIS_WARNING, "Opening socket: %s", server.neterr);
            exit(1);
        }
    }
    if (server.ipfd < 0 && server.sofd < 0) {
        redisLog(REDIS_WARNING, "Configured to not listen anywhere, exiting.");
        exit(1);
    }
```
8. 初始化数据库，按照dbnum创建db的dict/expires/blocking_keys/ready_keys/watched_keys
9. pubsub
10. CRON执行计数
11. rdb和aof初始化
12. 统计变量
13. 关联server cron到时间事件
14. 关联网络连接事件
```cpp
    if (server.ipfd > 0 
        ///将socket加入epoll监听，并设置可读时的回调处理函数        ///创建socket并监听
        && aeCreateFileEvent(server.el,server.ipfd,AE_READABLE, acceptTcpHandler,NULL) == AE_ERR) 
        redisPanic("Unrecoverable error creating server.ipfd file event.");
    if (server.sofd > 0 
        && aeCreateFileEvent(server.el,server.sofd,AE_READABLE, acceptUnixHandler,NULL) == AE_ERR) 
        redisPanic("Unrecoverable error creating server.sofd file event.");
```
网络事件处理流程简单梳理下：
- 创建监听socket,并将socket加入epoll监控，设置可读回调函数acceptTcpHandler
- acceptTcpHandler接受连接的socket，并调用acceptCommandHandler
- acceptCommandHandler调用createClient,创建新的客户端,如果客户端个数超过限制则关闭
- createClient首先对先连接的socket设置nonblock和nodelay，然后将socket加入epoll监听，设置可读回调readQueryFromClient如果客户端个数超过限制则关闭
- readQueryFromClient将请求读入querybuf,然后调用processInputBuffer来处理输入执行命令

15. 设置32位系统内存大小和内存策略
16. 如果集群模式打开则初始化集群
17. 初始化脚本环境
18. 初始化慢查询日志
19. 初始化后台IO
}

## aeMain主循环处理逻辑
从上面的主流程，我们可以看到，服务器的主循环逻辑就在aeMain这个函数里面，我们看下其代码如下:
```cpp
void aeMain(aeEventLoop *eventLoop) {

    eventLoop->stop = 0;

    while (!eventLoop->stop) {

        // 如果有需要在事件处理前执行的函数，那么运行它
        if (eventLoop->beforesleep != NULL)
            eventLoop->beforesleep(eventLoop);

        // 开始处理事件
        aeProcessEvents(eventLoop, AE_ALL_EVENTS);
    }
}
```

## aeProcessEvents流程
1. 函数原型：
    `int aeProcessEvents(aeEventLoop *eventLoop, int flags)`
2. 作用
    用来处理已经到达的时间事件和已经就绪的文件事件,根据传入的flag来控制操作行为
    0 == flag, 该函数不做任何处理，直接返回
    AE_ALL_EVENTS == flag, 所有类型的事件都会被处理
    AE_FILE_EVENTS == flag, 只处理文件事件
    AE_TIME_EVENTS == flag, 只处理时间事件
    AE_DONT_WAIT == flag, 处理完所有的非阻塞事件之后立即返回
3. 返回
    返回已经处理的时间的数量
4. 流程
int aeProcessEvents(aeEventLoop *eventLoop, int flags) {
1. flag判断
`if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;`

2. 获取最近的时间事件
3. 根据AE_DONT_WAIT参数决定是阻塞等待文件事件的时间
4. 处理到达的文件事件
```cpp
   numevents = aeApiPoll(eventLoop, tvp);
   for (j = 0; j < numevents; j++) {
       // 从已就绪数组中获取事件
       aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];

       int mask = eventLoop->fired[j].mask;
       int fd = eventLoop->fired[j].fd;
       int rfired = 0;

       /* note the fe->mask & mask & ... code: maybe an already processed
        * event removed an element that fired and we still didn't
        * processed, so we check if the event is still valid. */
       if (fe->mask & mask & AE_READABLE) {
           // 读事件
           rfired = 1; // 确保读/写事件只能执行其中一个
           fe->rfileProc(eventLoop,fd,fe->clientData,mask);
       }
       if (fe->mask & mask & AE_WRITABLE) {
           // 写事件
           if (!rfired || fe->wfileProc != fe->rfileProc)
               fe->wfileProc(eventLoop,fd,fe->clientData,mask);
       }

       processed++;
   }
```
5. 处理时间事件

}

## 处理读事件
当epoll监听的accept的socket可读，调用readQueryFromClient函数
readQueryFromClient将请求读入querybuf,然后调用processInputBuffer来处理输入执行命令
processInputBuffer根据不同的命令找到不同命令的处理方法
最后调用addReply, addReply调用prepareClientToWrite将fd设置可写回调sendReplyToClient
并将处理结果加入到客户端的回复中
```cpp
int prepareClientToWrite(redisClient *c) {
    if (c->flags & REDIS_LUA_CLIENT) return REDIS_OK;
    if (c->fd <= 0) return REDIS_ERR; /* Fake client */
    if (c->bufpos == 0 && listLength(c->reply) == 0 &&
        (c->replstate == REDIS_REPL_NONE || c->replstate == REDIS_REPL_ONLINE) &&
        aeCreateFileEvent(server.el, c->fd, AE_WRITABLE, sendReplyToClient, c) == AE_ERR)
        return REDIS_ERR;
    return REDIS_OK;
}
```


## 处理写事件
调用sendReplyToClient函数,后面再详细分析,先写几个觉得不错的点
- 为避免一个非常大的回复独占服务器，如果写入的字节数已经超过事件设定的每次可以写入的最大字节数，则中断发送
- 全部发送完毕之后，从epoll里删除可写的文件句柄监控


## 处理时间事件
调用`static int processTimeEvents(aeEventLoop *eventLoop)`处理时间时间，具体逻辑如下
static int processTimeEvents(aeEventLoop *eventLoop) {
while(time_event) {
1. 时间错乱的处理
如果时间有问题，就提前先执行第一个时间事件，早执行比无限等待好
```cpp
    if (now < eventLoop->lastTime) {
        te = eventLoop->timeEventHead;
        while(te) {
            te->when_sec = 0;
            te = te->next;
        }
    }
```
2. 执行时间事件
3. 判断是不是需要循环执行的事件，如果是循环执行的需要重新加到时间事件链表中
4. 取下一个时间事件
}


## 整体流程图
网上找的一个redis整体流程图，具体[链接](http://www.hoterran.info/redis_eventlibrary)
![redis整体流程图](redis-1-整体架构/redis_main_process.png)
{% asset_img "/redis_main_process.png" "Main" %}
