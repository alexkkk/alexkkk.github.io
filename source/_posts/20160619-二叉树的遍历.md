---
title: 二叉树的遍历
date: 2016-06-19 23:52:20
tags: algorithm
---

二叉树的遍历有如下的3种方法：
1. 先序遍历(root->left->right)
2. 中序遍历(left->root->right)
3. 后序遍历(left->right->root)

## 前提
二叉树的基本数据结构
```cpp
struct Node {
    int val;
    Node *left;
    Node *right;
    Node(int x) : val(x), left(nullptr), right(nullptr) {
    }

};
```

## 1.先序遍历
分别用递归和非递归的2种方法实现

### 1.1递归
时间复杂度O(N), 空间复杂度O(N)
```cpp
void preorder_traverse(const Node* root) {
    if (!root) return;
    cout << root->val << endl;
    preorder_traverse(root->left);
    preorder_traverse(root->right);
    return;
}
```

### 1.2非递归
时间复杂度O(N), 空间复杂度O(N)
```cpp
void preorder_traverse(const Node* root) {
    if (!root) return;
    stack<const Node*> s;
    s.push(root);
    const Node* p = nullptr;
    while (!s.empty()) {
        p = s.top();
        s.pop();
        cout << p->val << endl;
        if (p->left) {
            s.push(p->right);
        }
        if (p->right) {
            s.push(p->left);
        }
    }
    return;
}
```

### 1.3 morris先序遍历
```cpp
        void preorder_morris(const Node* root) {
            if (!root) return;
            auto p = root;
            while (p) {
                if (!p->left) {
                    cout << p->val << endl;
                    p = p->right;
                } else {
                    auto temp = p->left;
                    while (p != temp->right && temp->right) {
                        temp = temp->right;
                    }
                    if (!temp->right) {
                        ///第一次从左子的最右节点返回，直接访问节点
                    	cout << p->val << endl;
                        temp->right = p;
                        p = p->left;
                    } else {
                        ///第二次从左子的最右节点返回，已经都完成访问
                        ///拆开廉洁，同时转向访问右子
                        temp->right = nullptr;
                        p = p->right;
                    }

                }
            }
        }
```

## 2.中序遍历
分别用递归和非递归的2种方法实现
### 2.1递归
时间复杂度O(N), 空间复杂度O(N)
```cpp
void inorder_traverse(const Node* root) {
    if (!root) return;
    inorder_traverse(root->left);
    cout << root->val << endl;
    inorder_traverse(root->right);
    return;
}
```

### 2.2非递归
时间复杂度O(N), 空间复杂度O(N)
```cpp
void inorder_traverse(const Node* root) {
    if (!root) return;
    stack<const Node*> s;
    while (!s.empty() || root) {
        while (root) {
            s.push(root);
            root = root->left;
        }
        root = s.top();
        s.pop();
        cout << root->val << endl;
        root = root->right;
    }
    return;
}
```

### 2.3 morris中序遍历
时间复杂度O(N), 空间复杂度O(1)
用时间换空间
```cpp
void inorder_morris(const Node* root) {
    if (nullptr == root) return;
    auto p = root;
    while (p) {
        if (nullptr == p->left) {
            cout << p->val << endl;
            p = p->right;
        } else {
            auto temp = p->left;
            while (nullptr != temp->right && p != temp->right) {
                temp = temp->right;
            }
            if (nullptr == temp->right) {
                ///第一次访问节点p，p的左子还没有访问
                ///需要先访问p的左子
                temp->right = p;
                p = p->left;
            } else {
                ///p的左子已经访问完成，访问p本身，再访问p的右子
                ///要将原来建立的连接断开
                cout << p->val << endl;
                temp->right = nullptr;
                p = p->right;
            }
        }
    }
}
```

## 3.后序遍历
分别用递归和非递归的2种方法实现
### 3.1递归
时间复杂度O(N), 空间复杂度O(N)
```cpp
void postorder_traverse(const Node* root) {
    if (!root) return;
    postorder_traverse(root->left);
    postorder_traverse(root->right);
    cout << root->val << endl;
    return;
}
```

### 3.2非递归
时间复杂度O(N), 空间复杂度O(N)
```cpp
void postorder_traverse(const Node* root) {
    if (!root) return;
    const Node* pre = nullptr;
    stack<const Node*> s;
    do {
        while (root) {
            s.push(root);
            root = root->left;
        }
        pre = nullptr;
        ///可能一直在出栈
        while (!s.empty()) {
            root = s.top();
            ///从右边返回，或者右子是空
            if (root->right == pre) {
                cout << root->val << endl;
                s.pop();
                pre = root; //更新pre
            } else {
                root = root->right;
                break;
            }
        }
    } while (!s.empty())
}
```
### 3.3 morris后序遍历
```cpp
        void reverse(Node* from, Node* to) {
            Node* pre = nullptr;
            Node* cur = from;
            Node* temp = nullptr;
            while (to != pre) {
                temp = cur;
                cur = cur->right;
                temp->right = pre;
                pre = temp;
            }
        }

        void print_reverse(Node* from, Node* to) {
            cout << "from " << from->val << " to " << to->val << endl;
            if (from == to) {
                cout << from->val << endl;
                return;
            }
            reverse(from, to);
            for (auto p = to; p != nullptr; p = p->right) {
                cout << p->val << endl;
            }
            reverse(to, from);
        }

        void postorder_morris(Node* root) {
            if (!root) return;
            Node dummy(-1);
            dummy.left = root;
            auto p = &dummy;
            while (p) {
                if (!p->left) {
                    p = p->right;
                } else {
                    auto temp = p->left;
                    while (temp->right && p != temp->right) {
                        temp = temp->right;
                    }
                    if (!temp->right) {
                        //第一次从左子的最右节点返回，继续处理左子
                        temp->right = p;
                        p = p->left;
                    } else {
                        //第二次从左子的最右节点返回，反向输出节点
                        //断开之前建立的连接，并转向处理右子
                        print_reverse(p->left, temp);
                        temp->right = nullptr;
                        p = p->right;
                    }
                }
            }
        }
```


